syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.ackbox.raft";
option java_outer_classname = "RaftApiProto";
option objc_class_prefix = "API";

package com.ackbox.raft;

// The public node service definition.
service PublicNode {
    // Store new entries across nodes in the cluster.
    rpc set (SetRequest) returns (SetReply) {}

    // Retrieve entries stored across nodes in the cluster.
    rpc get (GetRequest) returns (GetReply) {}
}

// The internal node service definition.
service PrivateNode {
    // Starts an election for a given term.
    rpc vote (VoteRequest) returns (VoteReply) {}

    // Append entries to replicated log.
    rpc append (AppendRequest) returns (AppendReply) {}
}

// The vote request message.
message VoteRequest {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Candidate's term.
    int64 candidateTerm = 2;

    // Candidate's unique identifier.
    string candidateId = 3;

    // Index of candidate's last log entry.
    int64 lastLogIndex = 4;

    // Term of candidate's last log entry.
    int64 lastLogTerm = 5;
}

// The vote response message.
message VoteReply {
    // Possible status for a vote request.
    // - VOTE_GRANTED: if node granted the vote to the candidate.
    // - VOTE_NOT_GRANTED: if node did NOT grant the vote to the candidate.
    enum Status {
        VOTE_GRANTED = 0;
        VOTE_NOT_GRANTED = 1;
    }

    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Current term, for candidate to update itself.
    int64 currentTerm = 2;

    // Response status for the vote request.
    Status status = 3;
}

// The append entry request message.
message AppendRequest {
    // Object representing a log entry.
    message Entry {
        int64 index = 1;
        int64 term = 2;
        bytes entry = 3;
    }

    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Leader's term.
    int64 leaderTerm = 2;

    // Leader's unique identifier so follower can redirect clients.
    string leaderId = 3;

    // Leader's commit index.
    int64 leaderCommitIndex = 4;

    // Index of log entry immediately preceding new ones.
    int64 previousLogIndex = 5;

    // Term of previous log index entry.
    int64 previousLogTerm = 6;

    // Log entries to store (empty for heartbeat; may send more than one for efficiency).
    repeated Entry entries = 7;
}

// The append entry response message.
message AppendReply {
    // Possible status for an append request.
    // - SUCCESS: if follower was able to successfully append the log entries.
    // - LEADER_MISMATCH: if follower detects that there are multiple leaders in the cluster.
    // - TERM_MISMATCH: if follower's term does not agree with issuer of the request.
    // - LOG_STATE_MISMATCH: if follower contained entry matching previousLogIndex and previousLogTerm.
    enum Status {
        SUCCESS = 0;
        LEADER_MISMATCH = 1;
        TERM_MISMATCH = 2;
        LOG_STATE_MISMATCH = 3;
    }
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Current term, for leader to update itself.
    int64 currentTerm = 2;

    // Last entry index found in the node's log.
    int64 lastLogIndex = 3;

    // Status of the response if follower contained entry matching previousLogIndex and previousLogTerm.
    Status status = 4;
}

// Set replicated entry request message.
message SetRequest {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Data to be replicated across nodes.
    bytes entry = 2;
}

// Set replicated entry response message.
message SetReply {
    // Possible status for a set request.
    // - SUCCESS: leader node was able to append and commit entries.
    // - NOT_LEADER: request was sent to a node that is not the leader.
    // - COMMIT_ERROR: leader had issues committing the entries.
    enum Status {
        SUCCESS = 0;
        NOT_LEADER = 1;
        COMMIT_ERROR = 2;
    }
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Leader's unique identifier so follower can redirect clients.
    string leaderId = 2;

    // Sequence number assigned to the entry.
    int64 sqn = 3;

    // Status code for the response.
    Status status = 4;
}

// Get replicated entry request message.
message GetRequest {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Sequence number assigned to the entry.
    int64 sqn = 2;
}

// Get replicated entry response message.
message GetReply {
// Possible status for a set request.
    // - SUCCESS: leader node was able retrieve entries.
    // - NOT_LEADER: request was sent to a node that is not the leader.
    enum Status {
        SUCCESS = 0;
        NOT_LEADER = 1;
    }
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Leader's unique identifier so follower can redirect clients.
    string leaderId = 2;

    // Data to be replicated across nodes.
    bytes entry = 3;

    // Status code for the response.
    Status status = 4;
}
