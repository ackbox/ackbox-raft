syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.ackbox.raft";
option java_outer_classname = "RaftApiProto";
option objc_class_prefix = "API";

package com.ackbox.raft;

// The public node service definition.
service PublicNode {
    // Store new entries across nodes in the cluster.
    rpc set (SetRequest) returns (SetReply) {}

    // Retrieve entries stored across nodes in the cluster.
    rpc get (GetRequest) returns (GetReply) {}
}

// The internal node service definition.
service PrivateNode {
    // Starts an election for a given term.
    rpc vote (VoteRequest) returns (VoteReply) {}

    // Append entries to replicated log.
    rpc append (AppendRequest) returns (AppendReply) {}
}

// The vote request message.
message VoteRequest {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Candidate's term.
    int64 candidateTerm = 2;

    // Candidate's unique identifier.
    string candidateId = 3;

    // Index of candidate's last log entry.
    int64 lastLogIndex = 4;

    // Term of candidate's last log entry.
    int64 lastLogTerm = 5;
}

// The vote response message.
message VoteReply {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Current term, for candidate to update itself.
    int64 currentTerm = 2;

    // True if candidate received vote.
    bool isVoteGranted = 3;
}

// The append entry request message.
message AppendRequest {
    // Object representing a log entry.
    message Entry {
        int64 index = 1;
        int64 term = 2;
        bytes entry = 3;
    }

    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Leader's term.
    int64 leaderTerm = 2;

    // Leader's unique identifier so follower can redirect clients.
    string leaderId = 3;

    // Leader's commit index.
    int64 leaderCommitIndex = 4;

    // Index of log entry immediately preceding new ones.
    int64 previousLogIndex = 5;

    // Term of previous log index entry.
    int64 previousLogTerm = 6;

    // Log entries to store (empty for heartbeat; may send more than one for efficiency).
    repeated Entry entries = 7;
}

// The append entry response message.
message AppendReply {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Current term, for leader to update itself.
    int64 currentTerm = 2;

    // Last entry index found in the node's log.
    int64 lastLogIndex = 3;

    // True if follower contained entry matching previousLogIndex and previousLogTerm.
    bool isSuccess = 4;
}

// Set replicated entry request message.
message SetRequest {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Data to be replicated across nodes.
    bytes entry = 2;
}

// Set replicated entry response message.
message SetReply {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Leader's unique identifier so follower can redirect clients.
    string leaderId = 2;

    // Sequence number assigned to the entry.
    int64 sqn = 3;

    // True if the log was correctly replicated.
    bool isSuccess = 4;
}

// Get replicated entry request message.
message GetRequest {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Sequence number assigned to the entry.
    int64 sqn = 2;
}

// Get replicated entry response message.
message GetReply {
    // Request timestamp (wall clock from issuer).
    int64 timestamp = 1;

    // Leader's unique identifier so follower can redirect clients.
    string leaderId = 2;

    // Data to be replicated across nodes.
    bytes entry = 3;

    // True if the log was correctly replicated.
    bool isSuccess = 4;
}
